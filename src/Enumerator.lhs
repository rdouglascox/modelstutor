> module Enumerator (allmodels, prettyprint, allPairs, allTriples, newval) where

> import Data.List
> import GPLIevaluator
> import GPLIparser
> import System.Environment

> allmodels :: String -> [Model] 
> allmodels xs = concat (map (\x -> getmodels xs x) [[1],[1,2]])

DOMAINS

We want to enumerate all possible models given a fragment. Easy enough:

> domains :: [[Int]]
> domains = map (\x -> (take x [1..])) [1..]

> convertdomain :: [Int] -> Model' 
> convertdomain xs = Domain xs

REFERENTS

Now we need to ensure that we're going to get the right combinations for our zipping function. Expand and permute!

Let's do this better.

> refs xs ys = combinations (map (makepairs' ys) xs) 

> makepairs' xs x = [(x,y) | y <- xs]

> combinations' :: [[Model']] -> [[Model']]
> combinations' [] = [[]]
> combinations' (xs:xss) = [x : xs' | x <-xs, xs' <- combinations' xss]

Okay, I am just going to write conversation functions for the output of these to the right kind.

> convertrefs :: [[(Char,Int)]] -> [Model']
> convertrefs xs = [ Referents x | x <- xs ]

EXTENSIONS

Okay, so for extensions we do a similar thing.   

ONE-PLACE

We begin with:

> makepairs xs x = [(x,y) | y <- xs] 

And now we can do the following:

> predstocombos xs ys = map (makepairs (subsequences ys)) xs

This lists of all the possible values of each predicate. What we want now is just all possible ways of combining the elements in these lists. 

Actually, it doesn't quite work. It isn't getting combinations like [3,3,3] from [1,2,3]. Oh, but wait, that doesn't matter for the semantics of GPLI since [3,3,3] is eqivalent to [3], and that case *is* covered. Order doesn't matter for one-place predicate extensions.

> combinations :: [[a]] -> [[a]]
> combinations [] = [[]]
> combinations (xs:xss) = [x : xs' | x <-xs, xs' <- combinations xss]

> oneplace :: [Char] -> [Int] -> [[(Char,[Int])]]
> oneplace xs ys = combinations (predstocombos xs ys)

Okay, so this function for one-place predicate extensions is correct. It covers all of the relevant combinations. 

> convertoneplace :: [[(Char, [Int])]] -> [Model']
> convertoneplace xs = [OnePlace x | x <- xs] 

TWO-PLACE

Here is a helper function we will need for two-place and three-place.

> picks :: [x] -> [(x, [x])]
> picks [] = []
> picks (x:xs) = (x, xs) : [(y, x :ys) | (y,ys) <- picks xs]

And this will help.

> allPairs'' :: [x] -> [(x,x)]
> allPairs'' xs = [(y,z) | (y, ys) <- picks xs, z <- ys]

The problem with allPairs is that it doesn't give us combinations like (2,2) and (1,1) from [1,2]. If only we could get this. I suppose all we need to add is this:

> allPairs' :: [Int] -> [(Int,Int)]
> allPairs' xs = [(x,x) | x <- xs]  

> allPairs xs = (allPairs'' xs) ++ (allPairs' xs)

> predstocombos' xs ys = map (makepairs (subsequences (allPairs ys))) xs

> twoplace xs ys = combinations (predstocombos' xs ys)

But this isn't quite right! The trouble is that it is ignoring the fact that a predicate could have any combination of the pairs generated by allpairs. Here the order doesn't matter. All that matters is that we get all possible combinations. So subsequences will do.

> converttwoplace :: [[(Char, [(Int,Int)])]] -> [Model']
> converttwoplace xs = [TwoPlace x | x <- xs] 



THREE-PLACE

> predstocombos'' xs ys = map (makepairs (subsequences (allTriples ys))) xs

> threeplace xs ys = combinations (predstocombos'' xs ys)

Ah, crap. allTriples is missing triples like this (1,1,2) made from domains like [1,2]. This didn't matter for two place predicates since (1,2) and (1,1) / (2,2) were all we needed.

> allTriples xs = zip3 (alts1 xs) (alts2 xs) (alts3 xs)  

> alts3 xs = concat (replicate (((length xs) ^ 3) `div` (length xs)) xs)

> alts2 xs = concat (replicate (length xs) (concatMap (replicate (length xs)) xs))

> alts1 xs = concatMap (replicate ((length xs) ^ 2)) xs

> convertthreeplace :: [[(Char, [(Int,Int,Int)])]] -> [Model']
> convertthreeplace xs = [ThreePlace x | x <- xs] 



PUTTING IT ALL TOGETHER

First we need a data type to treat everything equally.

> data Model'  = Domain [Int] 
>             | Referents [(Char, Int)]   
>             | OnePlace [(Char, [Int])]
>             | TwoPlace [(Char, [(Int,Int)])]
>             | ThreePlace [(Char, [(Int,Int,Int)])]
>             deriving (Show)

 everything :: [Char] -> [Char] -> [Char] -> [Char] -> [Int] -> [[Model']]

> everything u v w x ys = map ((convertdomain ys) :) (combinations [convertrefs (refs u ys),convertoneplace (oneplace v ys),converttwoplace (twoplace w ys), convertthreeplace (threeplace x ys)])

Cool. So the function above gives us lists of models. What we really want it to take as an argument now is a formula. And we want it to get u v w x for itself, that is, the names, one, two, and three place predicates. Then, given a formula, and a domain, we get all the possible models!

Things are fine for a domain of [1] but we get a pretty fast combinatorial explosion at [1,2] with one, two, and three place predicates! We need some computing power there! The nice thing is that it seems to be more a matter of time than memory.

To Do: bring in getnames, getpreds, etc. 

> convertmodel :: [[Model']] -> [Model]
> convertmodel xs = map convertmodel' xs
>     where convertmodel' [Domain x, Referents y, OnePlace z, TwoPlace u, ThreePlace v] = Model x y z u v

Okay, so lets do something like `everything` above, except that it just takes a string and returns a function from domains to models. 

> getmodels :: [Char] -> [Int] -> [Model]
> getmodels x ys = convertmodel (everything (getnames x) (getpredicates1 (head(parser x))) (getpredicates2 (head(parser x))) (getpredicates3 (head(parser x))) ys)  

> newval :: [Char] -> Model  -> Bool 
> newval y x = val x (genassignment x y) (head (parser y))

Here's a cool function, then. It takes a formula and a domain and returns all the values on it.



> prettyprint :: Model -> [Char]
> prettyprint mod = "Model:\n Domain: " ++ show (domain mod) ++ "\n Referents: " ++ show (referents mod) ++ "\n Extensions:\n    One-place: " ++ show (extensions' mod) ++ "\n    Two-place: " ++ show (extensions'' mod) ++ "\n    Three-place: " ++ show (extensions''' mod)

MAIN



